<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Particules JS</title>
    <style>
        /* --- Reset & Base --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1a1a1a;
            /* Fond sombre */
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        h1 {
            margin-bottom: 20px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #38a3a5;
            /* Ta couleur de particules */
            text-transform: uppercase;
        }

        /* --- Conteneur des Particules --- */
        .particle-container {
            position: relative;
            width: 80vw;
            height: 60vh;
            background: #252525;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            overflow: hidden;
            /* Important pour que les particules ne débordent pas */
        }

        /* Le canvas prend toute la place du parent */
        .particles-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Petit footer discret */
        footer {
            margin-top: 20px;
            font-size: 0.8rem;
            color: #666;
        }
    </style>
</head>

<body>

    <h1>Réseau de Particules</h1>

    <div class="particle-container">
        <canvas class="particles-canvas"></canvas>
    </div>

    <footer>
        Projet hébergé sur GitHub
    </footer>

    <script>
        // Script Particules Vertes (Multi-Instances)
        const canvases = document.querySelectorAll('.particles-canvas');
        canvases.forEach(canvas => {
            if (canvas) {
                const ctx = canvas.getContext('2d');
                let particlesArray;
                let canvasParent = canvas.parentElement;

                function resizeCanvas() {
                    // On s'assure que le canvas matche la taille exacte de la div parent
                    canvas.width = canvasParent.offsetWidth;
                    canvas.height = canvasParent.offsetHeight;
                }

                resizeCanvas();

                let mouse = { x: null, y: null, radius: 150 }
                let globalMouse = { x: null, y: null };

                window.addEventListener('mousemove', function (event) {
                    globalMouse.x = event.clientX;
                    globalMouse.y = event.clientY;
                });

                window.addEventListener('mouseout', function () {
                    globalMouse.x = null;
                    globalMouse.y = null;
                });

                class Particle {
                    constructor(x, y, directionX, directionY, size, color) {
                        this.x = x; this.y = y; this.directionX = directionX; this.directionY = directionY; this.size = size; this.color = color;
                    }
                    draw() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                        ctx.fillStyle = this.color;
                        ctx.fill();
                    }
                    update() {
                        const rect = canvas.getBoundingClientRect(); // Position du canvas par rapport à la fenêtre

                        // Calcul de la souris relatif au canvas
                        let relativeMouseX = globalMouse.x - rect.left;
                        let relativeMouseY = globalMouse.y - rect.top;

                        let dx = relativeMouseX - this.x;
                        let dy = relativeMouseY - this.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        // Interaction souris (uniquement si la souris est dans le canvas ou proche)
                        if (globalMouse.x && distance < mouse.radius &&
                            globalMouse.x > rect.left && globalMouse.x < rect.right &&
                            globalMouse.y > rect.top && globalMouse.y < rect.bottom) {

                            const force = (mouse.radius - distance) / mouse.radius;
                            this.x -= (dx / distance) * force * 5;
                            this.y -= (dy / distance) * force * 5;
                        } else {
                            if (this.x > canvas.width || this.x < 0) this.directionX = -this.directionX;
                            if (this.y > canvas.height || this.y < 0) this.directionY = -this.directionY;
                            this.x += this.directionX;
                            this.y += this.directionY;
                        }
                        this.draw();
                    }
                }

                function init() {
                    particlesArray = [];
                    let numberOfParticles = (canvas.height * canvas.width) / 9000;
                    for (let i = 0; i < numberOfParticles; i++) {
                        let size = (Math.random() * 3) + 1;
                        let x = (Math.random() * ((canvas.width - size * 2) - (size * 2)) + size * 2);
                        let y = (Math.random() * ((canvas.height - size * 2) - (size * 2)) + size * 2);
                        particlesArray.push(new Particle(x, y, (Math.random() * 2) - 1, (Math.random() * 2) - 1, size, '#38a3a5'));
                    }
                }

                function animate() {
                    requestAnimationFrame(animate);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < particlesArray.length; i++) { particlesArray[i].update(); }
                    connect();
                }

                function connect() {
                    for (let a = 0; a < particlesArray.length; a++) {
                        for (let b = a; b < particlesArray.length; b++) {
                            let distance = ((particlesArray[a].x - particlesArray[b].x) ** 2) + ((particlesArray[a].y - particlesArray[b].y) ** 2);
                            // Ajustement dynamique de la distance de connexion selon la taille du canvas
                            if (distance < (canvas.width / 7) * (canvas.height / 7)) {
                                ctx.strokeStyle = 'rgba(56, 163, 165,' + (1 - (distance / 20000)) + ')'; // Légère modif opacité pour lissage
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                                ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                                ctx.stroke();
                            }
                        }
                    }
                }

                window.addEventListener('resize', function () { resizeCanvas(); init(); });
                init();
                animate();
            }
        });
    </script>
</body>

</html>